//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: simple.fbe
// FBE version: 1.15.0.0
//------------------------------------------------------------------------------

#include "simple.h"

namespace simple {

SimpleRequest::SimpleRequest()
    : id(FBE::uuid_t::sequential())
    , Message()
{}

SimpleRequest::SimpleRequest(const FBE::uuid_t& arg_id, const std::string& arg_Message)
    : id(arg_id)
    , Message(arg_Message)
{}

bool SimpleRequest::operator==(const SimpleRequest& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool SimpleRequest::operator<(const SimpleRequest& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void SimpleRequest::swap(SimpleRequest& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Message, other.Message);
}

std::ostream& operator<<(std::ostream& stream, const SimpleRequest& value)
{
    stream << "SimpleRequest(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Message="; stream << "\"" << value.Message << "\"";
    stream << ")";
    return stream;
}

SimpleResponse::SimpleResponse()
    : id(FBE::uuid_t::sequential())
    , Length((uint32_t)0ull)
    , Hash((uint32_t)0ull)
{}

SimpleResponse::SimpleResponse(const FBE::uuid_t& arg_id, uint32_t arg_Length, uint32_t arg_Hash)
    : id(arg_id)
    , Length(arg_Length)
    , Hash(arg_Hash)
{}

bool SimpleResponse::operator==(const SimpleResponse& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool SimpleResponse::operator<(const SimpleResponse& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void SimpleResponse::swap(SimpleResponse& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Length, other.Length);
    swap(Hash, other.Hash);
}

std::ostream& operator<<(std::ostream& stream, const SimpleResponse& value)
{
    stream << "SimpleResponse(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Length="; stream << value.Length;
    stream << ",Hash="; stream << value.Hash;
    stream << ")";
    return stream;
}

SimpleReject::SimpleReject()
    : id(FBE::uuid_t::sequential())
    , Error()
{}

SimpleReject::SimpleReject(const FBE::uuid_t& arg_id, const std::string& arg_Error)
    : id(arg_id)
    , Error(arg_Error)
{}

bool SimpleReject::operator==(const SimpleReject& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool SimpleReject::operator<(const SimpleReject& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void SimpleReject::swap(SimpleReject& other) noexcept
{
    using std::swap;
    swap(id, other.id);
    swap(Error, other.Error);
}

std::ostream& operator<<(std::ostream& stream, const SimpleReject& value)
{
    stream << "SimpleReject(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ",Error="; stream << "\"" << value.Error << "\"";
    stream << ")";
    return stream;
}

SimpleNotify::SimpleNotify()
    : Notification()
{}

SimpleNotify::SimpleNotify(const std::string& arg_Notification)
    : Notification(arg_Notification)
{}

bool SimpleNotify::operator==(const SimpleNotify& other) const noexcept
{
    return (
        true
        );
}

bool SimpleNotify::operator<(const SimpleNotify& other) const noexcept
{
    return false;
}

void SimpleNotify::swap(SimpleNotify& other) noexcept
{
    using std::swap;
    swap(Notification, other.Notification);
}

std::ostream& operator<<(std::ostream& stream, const SimpleNotify& value)
{
    stream << "SimpleNotify(";
    stream << "Notification="; stream << "\"" << value.Notification << "\"";
    stream << ")";
    return stream;
}

DisconnectRequest::DisconnectRequest()
    : id(FBE::uuid_t::sequential())
{}

DisconnectRequest::DisconnectRequest(const FBE::uuid_t& arg_id)
    : id(arg_id)
{}

bool DisconnectRequest::operator==(const DisconnectRequest& other) const noexcept
{
    return (
        (id == other.id)
        );
}

bool DisconnectRequest::operator<(const DisconnectRequest& other) const noexcept
{
    if (id < other.id)
        return true;
    if (other.id < id)
        return false;
    return false;
}

void DisconnectRequest::swap(DisconnectRequest& other) noexcept
{
    using std::swap;
    swap(id, other.id);
}

std::ostream& operator<<(std::ostream& stream, const DisconnectRequest& value)
{
    stream << "DisconnectRequest(";
    stream << "id="; stream << "\"" << value.id << "\"";
    stream << ")";
    return stream;
}

} // namespace simple
